{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/UnlonelyTournament.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\npragma solidity ^0.8.8;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract UnlonelyTournament is Ownable, ReentrancyGuard {\r\n    // Tournament is a struct that holds the state of a tournament, eventByte key pointing to the winning VIPBadge as well as the vip pooled ETH. Only one tournament is allowed at a time. This is intentional.\r\n    \r\n    enum EventType {\r\n        YayNayVote,\r\n        VIPBadge\r\n    }\r\n\r\n    struct Tournament {\r\n        bool isActive;\r\n        bool isPayoutClaimable;\r\n        bytes32 winningBadge;\r\n        uint256 vipPooledEth;\r\n    }\r\n\r\n    struct TradeInfo {\r\n        address trader;\r\n        bytes32 eventByte;\r\n        bool isBuy;\r\n        uint256 badgeAmount;\r\n        uint256 ethAmount;\r\n        uint256 protocolEthAmount;\r\n        uint256 subjectEthAmount;\r\n        uint256 tournamentEthAmount;\r\n        uint256 supply;\r\n        uint256 pooledEth;\r\n    }\r\n\r\n    Tournament public tournament;\r\n\r\n    address public protocolFeeDestination;\r\n    uint256 public protocolFeePercent;\r\n    uint256 public subjectFeePercent;\r\n    uint256 public tournamentFeePercent;\r\n\r\n    event Trade(TradeInfo trade);\r\n    event Payout(address indexed voter, uint256 amount);\r\n\r\n    mapping(bytes32 => uint256) public vipBadgeSupply;\r\n    mapping(bytes32 => mapping(address => uint256)) public vipBadgeBalance;\r\n    mapping(address => bool) public isTournamentCreator;\r\n\r\n    modifier onlyTournamentCreator() {\r\n        require(isTournamentCreator[msg.sender], \"Caller is not a tournament creator\");\r\n        _;\r\n    }\r\n\r\n    modifier validEventType(EventType eventType) {\r\n        require(\r\n            eventType == EventType.VIPBadge,\r\n            \"Invalid event type\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        // Set the contract deployer as the initial tournament creator\r\n        isTournamentCreator[msg.sender] = true;\r\n\r\n        protocolFeePercent = 5 * 10**16; // 5%\r\n        subjectFeePercent = 5 * 10**16;  // 5%\r\n        tournamentFeePercent = 5 * 10**16;  // 5%\r\n    }\r\n\r\n    function setFeeDestination(address _feeDestination) public onlyOwner {\r\n        protocolFeeDestination = _feeDestination;\r\n    }\r\n\r\n    function setProtocolFeePercent(uint256 _feePercent) public onlyOwner {\r\n        protocolFeePercent = _feePercent;\r\n    }\r\n\r\n    function setSubjectFeePercent(uint256 _feePercent) public onlyOwner {\r\n        subjectFeePercent = _feePercent;\r\n    }\r\n\r\n    function setTournamentFeePercent(uint256 _feePercent) public onlyOwner {\r\n        tournamentFeePercent = _feePercent;\r\n    }\r\n\r\n    function setTournamentCreator(address creator, bool value) public onlyOwner {\r\n        isTournamentCreator[creator] = value;\r\n    }\r\n\r\n\tfunction generateKey(address streamerAddress, uint256 eventId, EventType eventType) public pure validEventType(eventType) returns (bytes32) {\r\n        require(eventId < 1000000, \"ID must be less than 1 million\");\r\n        return keccak256(abi.encodePacked(streamerAddress, eventId, eventType));\r\n    }\r\n\r\n    function getTournamentPayout(address _address) public view returns (uint256){\r\n        if (!tournament.isPayoutClaimable) return 0;\r\n        uint256 totalPool = tournament.vipPooledEth;\r\n        uint256 totalWinningShares = vipBadgeSupply[tournament.winningBadge];\r\n        uint256 userPayout = totalWinningShares == 0 ? 0 : (totalPool * vipBadgeBalance[tournament.winningBadge][_address] / totalWinningShares);\r\n        return userPayout;\r\n    }\r\n\r\n    function getHolderBalance(address streamerAddress, uint256 eventId, EventType eventType, address holder) public view validEventType(eventType) returns (uint256 balance) {\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        return vipBadgeBalance[key][holder];\r\n    }\r\n\r\n    function getSupply(address streamerAddress, uint256 eventId, EventType eventType) public view validEventType(eventType) returns (uint256 supply) {\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        return vipBadgeSupply[key];\r\n    }\r\n\r\n    function getPrice(uint256 supply, uint256 amount) public pure returns (uint256) {\r\n        if (supply == 0 && amount == 0) return 0;\r\n\r\n        uint256 sum1 = supply == 0 ? 0 : (supply - 1) * supply * (2 * (supply - 1) + 1) / 6;\r\n        uint256 sum2 = (supply == 0 && amount == 1) ? 0 : (amount + supply - 1) * (supply + amount) * (2 * (amount + supply - 1) + 1) / 6;\r\n        uint256 summation = sum2 - sum1;\r\n        return summation * 1 ether / 32000;\r\n    }\r\n\r\n    function getBuyPrice(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public view validEventType(eventType) returns (uint256 price) {\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        uint256 supply = vipBadgeSupply[key];\r\n        return getPrice(supply, amount);\r\n    }\r\n\r\n    function getSellPrice(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public view validEventType(eventType) returns (uint256 price) {\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        uint256 supply = vipBadgeSupply[key];\r\n        if (supply < amount) return 0;\r\n        return getPrice(supply - amount, amount);\r\n    }\r\n\r\n    function getBuyPriceAfterFee(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public view validEventType(eventType) returns (uint256) {\r\n        uint256 price = getBuyPrice(streamerAddress, eventId, eventType, amount);\r\n        uint256 protocolFee = price * protocolFeePercent / 1 ether;\r\n        uint256 subjectFee = price * subjectFeePercent / 1 ether;\r\n        uint256 tournamentFee = tournament.isActive ? price * tournamentFeePercent / 1 ether : 0;\r\n        return price + protocolFee + subjectFee + tournamentFee;\r\n    }\r\n\r\n    function getSellPriceAfterFee(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public view validEventType(eventType) returns (uint256) {\r\n        uint256 price = getSellPrice(streamerAddress, eventId, eventType, amount);\r\n        uint256 protocolFee = price * protocolFeePercent / 1 ether;\r\n        uint256 subjectFee = price * subjectFeePercent / 1 ether;\r\n        uint256 tournamentFee = tournament.isActive ? price * tournamentFeePercent / 1 ether : 0;\r\n        return price - protocolFee - subjectFee - tournamentFee;\r\n    }\r\n\r\n    function startTournament() public onlyTournamentCreator {\r\n        require(!tournament.isActive, \"Tournament is already active.\");\r\n        require(!tournament.isPayoutClaimable, \"Winner payouts still allowed.\");\r\n        tournament = Tournament({\r\n            isActive: true,\r\n            isPayoutClaimable: false,\r\n            winningBadge: bytes32(0),\r\n            vipPooledEth: 0\r\n        });\r\n    }\r\n\r\n    function selectTournamentWinner(address streamerAddress, uint256 eventId, EventType eventType) public onlyTournamentCreator validEventType(eventType) {\r\n        require(tournament.isActive, \"Tournament is not active.\");\r\n        require(!tournament.isPayoutClaimable, \"Winner payouts already allowed.\");\r\n        bytes32 winningBadge = generateKey(streamerAddress, eventId, eventType);\r\n        tournament.winningBadge = winningBadge;\r\n        tournament.isPayoutClaimable = true;\r\n        tournament.isActive = false;\r\n    }\r\n    \r\n    function endTournament() public onlyTournamentCreator {\r\n        require(!tournament.isActive, \"Tournament still active.\");\r\n        require(tournament.isPayoutClaimable, \"Winner payouts already stopped.\");\r\n        tournament.isPayoutClaimable = false;\r\n        tournament.winningBadge = bytes32(0);\r\n    }\r\n\r\n    function buyVIPBadge(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public payable validEventType(eventType) {\r\n        require(protocolFeeDestination != address(0), \"protocolFeeDestination is the zero address\");\r\n        require(amount > 0, \"Cannot buy zero badges\");\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        require(key != tournament.winningBadge, \"Cannot buy winning badge during payout phase\");\r\n        uint256 price = getPrice(vipBadgeSupply[key], amount);\r\n        uint256 protocolFee = price * protocolFeePercent / 1 ether;\r\n        uint256 subjectFee = price * subjectFeePercent / 1 ether;\r\n        uint256 tournamentFee = tournament.isActive ? (price * tournamentFeePercent / 1 ether) : 0;  // Assume tournamentFeePercent is defined\r\n        require(msg.value >= price + protocolFee + subjectFee + tournamentFee, \"Insufficient payment\");\r\n\r\n        // Update the contract state\r\n        vipBadgeSupply[key] += amount;\r\n        vipBadgeBalance[key][msg.sender] += amount;\r\n        tournament.vipPooledEth += tournamentFee;\r\n\r\n        TradeInfo memory tradeInfo = TradeInfo({\r\n            trader: msg.sender,\r\n            eventByte: key,\r\n            isBuy: true,\r\n            badgeAmount: amount,\r\n            ethAmount: price,\r\n            protocolEthAmount: protocolFee,\r\n            subjectEthAmount: subjectFee,\r\n            tournamentEthAmount: tournamentFee,\r\n            supply: vipBadgeSupply[key],\r\n            pooledEth: tournament.vipPooledEth\r\n        });\r\n\r\n        emit Trade(tradeInfo);\r\n\r\n        // Send protocol and subject fees\r\n        (bool success1, ) = protocolFeeDestination.call{value: protocolFee}(\"\");\r\n        (bool success2, ) = streamerAddress.call{value: subjectFee}(\"\");\r\n        require(success1 && success2, \"Unable to send funds\");\r\n    }\r\n\r\n    function sellVIPBadge(address streamerAddress, uint256 eventId, EventType eventType, uint256 amount) public validEventType(eventType) nonReentrant {\r\n        require(protocolFeeDestination != address(0), \"protocolFeeDestination is the zero address\");\r\n        require(amount > 0, \"Cannot buy zero badges\");\r\n        bytes32 key = generateKey(streamerAddress, eventId, eventType);\r\n        require(vipBadgeBalance[key][msg.sender] >= amount, \"Insufficient badges\");\r\n        uint256 price = getPrice(vipBadgeSupply[key] - amount, amount);\r\n        uint256 protocolFee = price * protocolFeePercent / 1 ether;\r\n        uint256 subjectFee = price * subjectFeePercent / 1 ether;\r\n        uint256 tournamentFee = tournament.isActive ? (price * tournamentFeePercent / 1 ether) : 0;  // Assume tournamentFeePercent is defined\r\n\r\n        // Update the contract state\r\n        vipBadgeSupply[key] -= amount;\r\n        vipBadgeBalance[key][msg.sender] -= amount;\r\n        tournament.vipPooledEth += tournamentFee;\r\n\r\n        TradeInfo memory tradeInfo = TradeInfo({\r\n            trader: msg.sender,\r\n            eventByte: key,\r\n            isBuy: false,\r\n            badgeAmount: amount,\r\n            ethAmount: price,\r\n            protocolEthAmount: protocolFee,\r\n            subjectEthAmount: subjectFee,\r\n            tournamentEthAmount: tournamentFee,\r\n            supply: vipBadgeSupply[key],\r\n            pooledEth: tournament.vipPooledEth\r\n        });\r\n\r\n        emit Trade(tradeInfo);\r\n\r\n        // Send protocol and subject fees\r\n        (bool success1, ) = protocolFeeDestination.call{value: protocolFee}(\"\");\r\n        (bool success2, ) = streamerAddress.call{value: subjectFee}(\"\");\r\n        require(success1 && success2, \"Unable to send funds\");\r\n\r\n        // Send the remaining amount to the seller\r\n        uint256 netAmount = price - protocolFee - subjectFee - tournamentFee;\r\n        (bool success3, ) = msg.sender.call{value: netAmount}(\"\");\r\n        require(success3, \"Unable to send funds\");\r\n    }\r\n\r\n    function claimTournamentPayout() public nonReentrant {\r\n        require(tournament.isPayoutClaimable, \"Winner payout not allowed right now\");\r\n        require(vipBadgeBalance[tournament.winningBadge][msg.sender] > 0, \"No VIP badges to claim payout for.\");\r\n        uint256 totalPool = tournament.vipPooledEth;\r\n        uint256 totalWinningShares = vipBadgeSupply[tournament.winningBadge];\r\n        uint256 userPayout = totalWinningShares == 0 ? 0 : (totalPool * vipBadgeBalance[tournament.winningBadge][msg.sender] / totalWinningShares);\r\n        require(userPayout > 0, \"No payout for user\");\r\n\r\n        // Reset user's shares after distributing\r\n        vipBadgeSupply[tournament.winningBadge] -= vipBadgeBalance[tournament.winningBadge][msg.sender];\r\n        vipBadgeBalance[tournament.winningBadge][msg.sender] = 0;\r\n\r\n        // Deduct the user's payout from the sharesSubject's pool\r\n        tournament.vipPooledEth -= userPayout;\r\n\r\n        emit Payout(msg.sender, userPayout);\r\n        (bool success, ) = msg.sender.call{value: userPayout}(\"\");\r\n        require(success, \"Unable to send funds\");\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}